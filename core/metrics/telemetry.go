package metrics

import (
	"context"
	"fmt"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/adaptor"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/prometheus/client_golang/prometheus/push"
	dto "github.com/prometheus/client_model/go"
	"github.com/ryanolee/go-pot/config"
	"github.com/ryanolee/go-pot/protocol/http/logging"
	"go.uber.org/fx"
	"go.uber.org/zap"
)

type (
	TelemetryInput struct {
		NodeName string
	}
	Telemetry struct {
		nodeName string

		// Push Gateway
		pushGatewayEnabled      bool
		pushGatewayEndpoint     string
		pushGatewayIntervalSecs int
		pushGatewayUsername     string
		pushGatewayPassword     string

		// Server
		serverEnabled bool
		serverPort    int
		serverPath    string
		app           *fiber.App

		// Prometheus
		metricsTrackTimeWasted       bool
		metricsTrackSecretsGenerated bool

		// Internals
		wastedTimeCounter       prometheus.Counter
		secretsGeneratedCounter prometheus.Counter
		shutdownChan            chan bool

		// Logger
		logger *zap.Logger
	}
)

func NewTelemetry(lf fx.Lifecycle, config *config.Config, logger *zap.Logger) (*Telemetry, error) {
	if !config.Telemetry.Enabled {
		return nil, nil
	}

	telemetry := &Telemetry{
		nodeName: config.Telemetry.NodeName,

		// Push Gateway
		pushGatewayEnabled:      config.Telemetry.PushGateway.Enabled,
		pushGatewayEndpoint:     config.Telemetry.PushGateway.Endpoint,
		pushGatewayIntervalSecs: config.Telemetry.PushGateway.PushIntervalSecs,
		pushGatewayUsername:     config.Telemetry.PushGateway.Username,
		pushGatewayPassword:     config.Telemetry.PushGateway.Password,

		// Server
		serverEnabled: config.Telemetry.Prometheus.Enabled,
		serverPort:    config.Telemetry.Prometheus.Port,
		serverPath:    config.Telemetry.Prometheus.Path,

		// Metrics
		metricsTrackTimeWasted:       config.Telemetry.Metrics.TrackTimeWasted,
		metricsTrackSecretsGenerated: config.Telemetry.Metrics.TrackSecretsGenerated,

		// Internals
		wastedTimeCounter: prometheus.NewCounter(prometheus.CounterOpts{
			Name: "time_wasted",
			Help: "Time wasted by clients calling this service",
		}),
		secretsGeneratedCounter: prometheus.NewCounter(prometheus.CounterOpts{
			Name: "secrets_generated",
			Help: "Number of secrets generated by this service",
		}),
		shutdownChan: make(chan bool, 1),

		// Logger
		logger: logger,
	}

	lf.Append(fx.Hook{
		OnStart: func(ctx context.Context) error {
			telemetry.StartPushGateway()
			telemetry.StartMetricsServer()
			return nil
		},
		OnStop: func(ctx context.Context) error {
			if err := telemetry.Stop(); err != nil {
				return err
			}
			return nil
		},
	})

	return telemetry, nil
}

func (t *Telemetry) StartPushGateway() {
	if !t.pushGatewayEnabled {
		t.logger.Sugar().Infof("Push Gateway is not enabled")
		return
	}

	registry := t.getPrometheusRegistry()

	go func() {
		pushTicker := time.NewTicker(time.Second * time.Duration(t.pushGatewayIntervalSecs))
		for {
			select {
			case <-t.shutdownChan:
				return
			case <-pushTicker.C:
				if err := t.getAuthedClient().Gatherer(registry).Push(); err != nil {
					t.logger.Sugar().Errorw("Failed to push metrics", "error", err)
				}
			}
		}
	}()
}

func (t *Telemetry) StartMetricsServer() {
	if !t.serverEnabled {
		return
	}

	t.logger.Sugar().Infof("Starting metrics server on port %d", t.serverPort)
	t.app = fiber.New(fiber.Config{
		DisableStartupMessage: true,
	})
	logger := logging.NewServerLogger(t.logger.Named("metrics-server"))
	logger.Use(t.app)
	t.app.Get(t.serverPath, adaptor.HTTPHandler(promhttp.HandlerFor(t.getPrometheusRegistry(), promhttp.HandlerOpts{})))
	go func() {
		if err := t.app.Listen(fmt.Sprintf(":%d", t.serverPort)); err != nil {
			// Not sure how to handle this error
			t.logger.Sugar().Fatalw("Failed to start metrics server", "error", err)
		}
	}()
}

func (t *Telemetry) Stop() error {
	t.logger.Sugar().Warnw("Stopping telemetry")
	if err := t.StopPushGateway(); err != nil {
		return err
	}
	if err := t.StopMetricsServer(); err != nil {
		return err
	}
	t.logger.Sugar().Warnw("Stopped telemetry")
	return nil
}

func (t *Telemetry) StopPushGateway() error {
	if !t.pushGatewayEnabled {
		return nil
	}
	// Shutdown push gateway
	t.shutdownChan <- true
	t.logger.Sugar().Infof("Deleting metrics from push gateway")
	if err := t.getAuthedClient().Delete(); err != nil {
		t.logger.Sugar().Errorw("Failed to delete metrics", "error", err)
		return err
	}

	return nil
}

func (t *Telemetry) StopMetricsServer() error {
	if !t.serverEnabled {
		return nil
	}

	t.logger.Sugar().Infof("Shutting down metrics server")
	return t.app.Shutdown()
}

func (t *Telemetry) getPrometheusRegistry() *prometheus.Registry {
	registry := prometheus.NewRegistry()

	if t.metricsTrackTimeWasted {
		registry.MustRegister(t.wastedTimeCounter)
	}

	if t.metricsTrackSecretsGenerated {
		registry.MustRegister(t.secretsGeneratedCounter)
	}

	return registry
}

func (t *Telemetry) getAuthedClient() *push.Pusher {
	client := push.New(t.pushGatewayEndpoint, t.nodeName)

	if t.pushGatewayUsername != "" && t.pushGatewayPassword != "" {
		return client.BasicAuth(t.pushGatewayUsername, t.pushGatewayPassword)
	}
	return client
}

func (t *Telemetry) TrackWastedTime(wastedTime time.Duration) {
	t.wastedTimeCounter.Add(wastedTime.Seconds())
}

func (t *Telemetry) GetWastedTime() float64 {
	return t.getCounterValue(t.wastedTimeCounter)
}

func (t *Telemetry) TrackGeneratedSecrets(generatedSecrets int) {
	t.secretsGeneratedCounter.Add(float64(generatedSecrets))
}

func (t *Telemetry) getCounterValue(counter prometheus.Counter) float64 {
	m := &dto.Metric{}
	if err := counter.Write(m); err != nil {
		t.logger.Sugar().Errorw("Failed to pull metric data", "error", err)
		return 0
	}
	return m.GetCounter().GetValue()
}
