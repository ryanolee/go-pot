package metrics

import (
	"math"
	"strconv"
	"sync"
	"time"

	"github.com/patrickmn/go-cache"
	"github.com/ryanolee/go-pot/config"
	"github.com/ryanolee/go-pot/core/gossip/action"
	"go.uber.org/zap"
)

type (
	// Timeout watcher aggregates timeouts for a given IP address in order to
	// Current model for working out timeout is as follows:
	//   - Begin keeping track of timeouts of and IP address the "hot cache pool" until:
	//      - We have a timeout that is longer than "instantCommitThreshold"
	//      - We have a standard deviation of timeouts that is less than "sampleDeviation"
	//   - Then we commit the timeout to the "cold cache pool" and delete the IP from the "hot cache pool"
	//   - Broadcast the committed timeout to other nodes in the cluster
	//   - Always return the known timeout for an IP address from the "cold cache pool"

	TimeoutWatcher struct {
		// Cache pool for IP addresses we are actively trying to work out timeout for
		hotCachePool *cache.Cache

		// Cache pool for IP addresses we have already worked out the IP timeouts for
		coldCachePool *cache.Cache

		actionDispatcher action.IBroadcastActionDispatcher
		logger           *zap.Logger

		opts *TimeoutWatcherOptions
	}

	TimeoutWatcherOptions struct {
		// The maximum amount of time a given IP can be hanging before we consider the IP
		// to be vulnerable to hanging forever on a request. Any ips that get past this threshold
		// will always be given the longest timeout
		instantCommitThreshold time.Duration

		// The upper bound for increasing timeouts. Once the timeout increases to reach this bound we will hang forever.
		upperTimeoutBound time.Duration

		// The smallest timeout we will ever give
		lowerTimeoutBound time.Duration

		// The increment we will increase timeouts by for requests with timeouts larger than 30 seconds
		timeoutOverThirtyIncrement time.Duration

		// The increment we will increase timeouts by for requests with timeouts smaller than 30 seconds
		timeoutSubThirtyIncrement time.Duration

		// The increment we will increase timeouts by for requests with timeouts smaller than 10 seconds
		timeoutSubTenIncrement time.Duration

		// The number of requests that are allowed before things begin slowing down
		graceRequests int

		// The timeout we will give to requests that are allowed to pass the grace period
		graceTimeout time.Duration

		// The amount of time to wait when hanging an IP "forever"
		longestTimeout time.Duration

		// The number of samples to take to detect a timeout
		sampleSize int

		// How close the standards need to be on average to move the IP address into the "Endless stall" category
		sampleDeviation time.Duration
	}

	// Timeout for an IP address we have been able to work out who's timeout is
	CommittedTimeoutForIp struct {
		Timeout time.Duration
		Ip      string
	}

	// Struct representing the traffic for a given IP address
	TimeoutForIp struct {
		// Options for the timeout watcher associated with this IP Timeout
		opts *TimeoutWatcherOptions

		// Mutex for sync operations relating to the given IP
		mutex sync.RWMutex

		// The number of requests that have been made by an given IP to this node
		Requests int

		// The duration of the last N timeouts that finished successfully
		ValidTimeouts []time.Duration

		// The duration of the last N timeouts that finished with a client timeout
		InvalidTimeouts []time.Duration

		// The duration of the last valid timeout
		LastValidTimeout time.Duration

		// The duration of the last invalid timeout
		LastInvalidTimeout time.Duration

		// The duration of the last timeout that was attempted
		LastPerformedTimeout time.Duration
	}
)

func NewTimeoutForIp(opts *TimeoutWatcherOptions) *TimeoutForIp {
	return &TimeoutForIp{
		mutex:                sync.RWMutex{},
		opts:                 opts,
		Requests:             0,
		ValidTimeouts:        make([]time.Duration, 0),
		InvalidTimeouts:      make([]time.Duration, 0),
		LastValidTimeout:     0,
		LastInvalidTimeout:   0,
		LastPerformedTimeout: 0,
	}
}

func (t *TimeoutForIp) CalculateNextTimeout() time.Duration {
	if t.Requests < t.opts.graceRequests {
		return t.opts.graceTimeout
	}

	if t.LastPerformedTimeout < time.Second*10 {
		return t.LastPerformedTimeout + t.opts.timeoutSubTenIncrement
	}

	if t.LastPerformedTimeout < time.Second*30 {
		return t.LastPerformedTimeout + t.opts.timeoutSubThirtyIncrement
	}

	if t.LastPerformedTimeout < t.opts.upperTimeoutBound {
		return t.LastPerformedTimeout + t.opts.timeoutOverThirtyIncrement
	}

	return t.opts.longestTimeout
}

func (t *TimeoutForIp) GetNextTimeout() time.Duration {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	timeout := t.CalculateNextTimeout()
	t.Requests += 1
	t.LastPerformedTimeout = timeout
	return timeout
}

func (t *TimeoutForIp) GetStandardDeviation() time.Duration {
	avg := float64(t.GetAverageTimeoutInSample())
	if avg == -1 {
		return -1
	}

	startingPos := len(t.InvalidTimeouts) - t.opts.sampleSize
	squaredSum := float64(0)
	for i := startingPos; i < len(t.InvalidTimeouts); i++ {
		squaredSum += math.Pow(math.Abs(avg-float64(t.InvalidTimeouts[i])), 2)
	}

	return time.Duration(math.Sqrt(squaredSum / float64(t.opts.sampleSize)))
}

func (t *TimeoutForIp) GetAverageTimeoutInSample() time.Duration {
	if len(t.InvalidTimeouts) < t.opts.sampleSize {
		return -1
	}

	sum := float64(0)
	for i := 0; i < len(t.InvalidTimeouts); i++ {
		sum += float64(t.InvalidTimeouts[i])
	}
	return time.Duration(sum / float64(t.opts.sampleSize))
}

func (t *TimeoutForIp) RecordInvalidTimeout(timeout time.Duration) {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	t.InvalidTimeouts = append(t.InvalidTimeouts, timeout)
	t.LastInvalidTimeout = timeout

	if len(t.InvalidTimeouts) > t.opts.sampleSize {
		t.InvalidTimeouts = t.InvalidTimeouts[1:]
	}
}

func (t *TimeoutForIp) RecordValidTimeout(timeout time.Duration) {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	t.ValidTimeouts = append(t.ValidTimeouts, timeout)
	t.LastValidTimeout = timeout

	if len(t.ValidTimeouts) > t.opts.sampleSize {
		t.ValidTimeouts = t.ValidTimeouts[1:]
	}
}

func NewTimeoutWatcher(config *config.Config, logger *zap.Logger) *TimeoutWatcher {
	if !config.TimeoutWatcher.Enabled {
		return nil
	}

	twConfig := &config.TimeoutWatcher

	return &TimeoutWatcher{
		actionDispatcher: nil,
		hotCachePool:     cache.New(time.Duration(twConfig.CacheHotPoolTTL)*time.Second, time.Minute),
		coldCachePool:    cache.New(time.Duration(twConfig.CacheColdPoolTTL)*time.Second, time.Hour),
		logger:           logger,

		// Map options from config to TimeoutWatcherOptions
		opts: &TimeoutWatcherOptions{
			instantCommitThreshold:     time.Duration(twConfig.InstantCommitThreshold) * time.Millisecond,
			upperTimeoutBound:          time.Duration(twConfig.UpperTimeoutBound) * time.Millisecond,
			lowerTimeoutBound:          time.Duration(twConfig.LowerTimeoutBound) * time.Millisecond,
			timeoutOverThirtyIncrement: time.Duration(twConfig.TimeoutOverThirtyIncrement) * time.Millisecond,
			timeoutSubThirtyIncrement:  time.Duration(twConfig.TimeoutSubThirtyIncrement) * time.Millisecond,
			timeoutSubTenIncrement:     time.Duration(twConfig.TimeoutSubTenIncrement) * time.Millisecond,
			graceRequests:              twConfig.GraceRequests,
			graceTimeout:               time.Duration(twConfig.GraceTimeout) * time.Millisecond,
			longestTimeout:             time.Duration(twConfig.LongestTimeout) * time.Millisecond,
			sampleSize:                 twConfig.DetectionSampleSize,
			sampleDeviation:            time.Duration(twConfig.DetectionSampleDeviation) * time.Millisecond,
		},
	}
}

func (tw *TimeoutWatcher) SetActionDispatcher(actionDispatcher action.IBroadcastActionDispatcher) {
	tw.actionDispatcher = actionDispatcher
}

func (tw *TimeoutWatcher) RecordResponse(identifier string, timeout time.Duration, successful bool) {
	var data *TimeoutForIp
	result, ok := tw.hotCachePool.Get(identifier)

	if !ok {
		result = NewTimeoutForIp(tw.opts)
	}

	if data, ok = result.(*TimeoutForIp); !ok {
		tw.logger.Sugar().Warn("Failed to cast timeout data for IP address. Resetting", "ip", identifier)
		data = NewTimeoutForIp(tw.opts)
	}

	if successful {
		data.RecordValidTimeout(timeout)
	} else {
		data.RecordInvalidTimeout(timeout)
	}

	if !successful && timeout > tw.opts.instantCommitThreshold {
		tw.logger.Sugar().Infow("Timeout recorded higher than instant commit threshold", "ip", identifier, "timeout", timeout)
		tw.CommitToColdCacheWithBroadcast(identifier, tw.opts.longestTimeout)
		return
	}

	if len(data.InvalidTimeouts) < tw.opts.sampleSize {
		return
	}

	sd := data.GetStandardDeviation()
	if sd < 0 {
		return
	}

	if sd > tw.opts.sampleDeviation {
		return
	}
	tw.logger.Sugar().Infow("Standard deviation is low. We have probably found the timeout! Committing to cold cache", "ip", identifier, "sd", sd)
	avg := data.GetAverageTimeoutInSample()
	timeoutToCommit := avg - (sd * 2)
	if timeoutToCommit < tw.opts.lowerTimeoutBound {
		timeoutToCommit = tw.opts.lowerTimeoutBound
	}

	tw.logger.Sugar().Infow("Committed to cold cache", "ip", identifier, "timeout", timeoutToCommit)
	tw.CommitToColdCacheWithBroadcast(identifier, timeoutToCommit)
}

func (tw *TimeoutWatcher) CommitToColdCache(identifier string, timeout time.Duration) {
	tw.coldCachePool.Set(identifier, timeout, cache.DefaultExpiration)
	tw.hotCachePool.Delete(identifier)
}

func (tw *TimeoutWatcher) CommitToColdCacheWithBroadcast(identifier string, timeout time.Duration) {
	tw.CommitToColdCache(identifier, timeout)
	tw.BroadcastColdCacheIp(identifier, timeout)
}

func (tw *TimeoutWatcher) HasColdCacheTimeout(identifier string) bool {
	_, ok := tw.coldCachePool.Get(identifier)
	return ok
}

func (tw *TimeoutWatcher) BroadcastColdCacheIp(identifier string, timeout time.Duration) {
	if tw.actionDispatcher == nil {
		return
	}

	tw.actionDispatcher.Dispatch(&action.BroadcastAction{
		Action: "ADD_COLD_IP",
		Data:   identifier + "," + strconv.Itoa(int(timeout)),
	})
}

func (tw *TimeoutWatcher) GetTimeout(identifier string) time.Duration {
	tw.coldCachePool.Get(identifier)
	if timeout, ok := tw.coldCachePool.Get(identifier); ok {
		if timeout, ok := timeout.(time.Duration); ok {
			return timeout
		}

		tw.logger.Sugar().Warn("Failed to cast timeout data for IP address. Resetting", "ip", identifier)
		tw.coldCachePool.Delete(identifier)
	}

	var data *TimeoutForIp
	result, ok := tw.hotCachePool.Get(identifier)

	if !ok {
		result = NewTimeoutForIp(tw.opts)
	}

	if data, ok = result.(*TimeoutForIp); !ok {
		tw.logger.Sugar().Warn("Failed to cast timeout data for IP address. Resetting", "ip", identifier)
		data = NewTimeoutForIp(tw.opts)
	}

	tw.hotCachePool.Set(identifier, data, cache.DefaultExpiration)

	timeout := data.GetNextTimeout()

	return timeout
}
